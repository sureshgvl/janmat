rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Users can read and write their own data
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;

      // Device management for multi-device login prevention
      match /devices/{deviceId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Wards are publicly readable
    match /wards/{wardId} {
      allow read: if true;
    }

    // Candidates are publicly readable
    match /candidates/{candidateId} {
      allow read: if true;
    }

    // Cities collection (for nested candidate structure)
    match /cities/{cityId} {
      allow read: if true;

      // Wards within cities
      match /wards/{wardId} {
        allow read: if true;

        // Candidates within wards
        match /candidates/{candidateId} {
          allow read: if true;

          // Allow authenticated users to create candidates (self-registration)
          allow create: if request.auth != null &&
            request.auth.uid == request.resource.data.userId &&
            // Ensure user hasn't already registered as candidate
            !_userHasRegisteredAsCandidate(request.auth.uid);

          // Allow admins to update candidate approval and status
          allow update: if request.auth != null && _isAdmin(request.auth.uid);

          // Followers subcollection
          match /followers/{userId} {
            // Users can read/write their own follow relationships
            allow read, write: if request.auth != null && request.auth.uid == userId;
            // Allow read for everyone (to display follower counts)
            allow read: if true;
          }
        }
      }
    }

    // Users following subcollection
    match /users/{userId}/following/{candidateId} {
      // Users can read/write their own following relationships
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Users can read/write their own conversations
    match /conversations/{conversationId} {
      allow read, write: if request.auth != null &&
        (conversationId.split('_')[0] == request.auth.uid ||
         conversationId.split('_')[1] == request.auth.uid);
    }

    // Users can read/write their own rewards
    match /rewards/{rewardId} {
      allow read, write: if request.auth != null &&
        resource.data.userId == request.auth.uid;
    }

    // Users can read/write their own XP transactions
    match /xp_transactions/{transactionId} {
      allow read, write: if request.auth != null &&
        resource.data.userId == request.auth.uid;
    }

    // Chat rooms - public ward groups and private conversations
    match /chats/{roomId} {
      // Allow read for authenticated users in public rooms or members of private rooms
      allow read: if request.auth != null &&
        (resource.data.type == 'public' ||
         (resource.data.type == 'private' && request.auth.uid in resource.data.members));

      // Allow create for admins and candidates
      allow create: if request.auth != null &&
        (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['admin', 'candidate']);

      // Allow update for room creator or admins
      allow update: if request.auth != null &&
        (resource.data.createdBy == request.auth.uid ||
         _isAdmin(request.auth.uid));

      // Allow delete for admins only
      allow delete: if request.auth != null &&
        _isAdmin(request.auth.uid);
    }

    // Messages in chat rooms
    match /chats/{roomId}/messages/{messageId} {
      // Allow read for authenticated users who can access the room
      allow read: if request.auth != null &&
        (get(/databases/$(database)/documents/chats/$(roomId)).data.type == 'public' ||
         request.auth.uid in get(/databases/$(database)/documents/chats/$(roomId)).data.members);

      // Allow create for authenticated users who can access the room
      // With quota check for voters (except premium users)
      allow create: if request.auth != null &&
        (get(/databases/$(database)/documents/chats/$(roomId)).data.type == 'public' ||
         request.auth.uid in get(/databases/$(database)/documents/chats/$(roomId)).data.members) &&
        (_canSendMessage(request.auth.uid));

      // Allow update/delete for message sender or admins
      allow update, delete: if request.auth != null &&
        (resource.data.senderId == request.auth.uid ||
         _isAdmin(request.auth.uid));
    }

    // User quotas for message sending
    match /user_quotas/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Reported messages for moderation
    match /reported_messages/{reportId} {
      allow read: if request.auth != null &&
        _isAdmin(request.auth.uid);
      allow create: if request.auth != null;
    }

    // Polls in chat rooms
    match /chats/{roomId}/polls/{pollId} {
      allow read: if request.auth != null &&
        (get(/databases/$(database)/documents/chats/$(roomId)).data.type == 'public' ||
         request.auth.uid in get(/databases/$(database)/documents/chats/$(roomId)).data.members);

      allow create: if request.auth != null &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['admin', 'candidate'];

      allow update: if request.auth != null &&
        (resource.data.createdBy == request.auth.uid ||
         _isAdmin(request.auth.uid));
    }

    // Poll votes
    match /chats/{roomId}/polls/{pollId}/votes/{voteId} {
      allow read: if request.auth != null &&
        (get(/databases/$(database)/documents/chats/$(roomId)).data.type == 'public' ||
         request.auth.uid in get(/databases/$(database)/documents/chats/$(roomId)).data.members);

      allow create, update: if request.auth != null &&
        request.auth.uid == voteId &&
        !exists(/databases/$(database)/documents/chats/$(roomId)/polls/$(pollId)/votes/$(request.auth.uid));
    }
  }

  // Helper function to check if user can send message (quota/premium check)
  function _canSendMessage(userId) {
    let user = get(/databases/$(database)/documents/users/$(userId)).data;
    let quota = get(/databases/$(database)/documents/user_quotas/$(userId)).data;

    // Premium users and candidates have unlimited messages
    return user.role in ['candidate', 'admin'] || user.premium == true ||
           (quota != null && quota.messagesSent < quota.dailyLimit + (quota.extraQuota or 0));
  }

  // Helper function to check if user is admin
  function _isAdmin(userId) {
    let user = get(/databases/$(database)/documents/users/$(userId)).data;
    return user != null && user.role == 'admin';
  }

  // Helper function to check if user has already registered as candidate
  function _userHasRegisteredAsCandidate(userId) {
    // This is a simplified check - in practice, you might need to query all cities/wards
    // For now, we'll allow the repository to handle this check
    return false;
  }

  // Monetization Rules

  // Plans collection - publicly readable
  match /plans/{planId} {
    allow read: if true;
    allow write: if _isAdmin(request.auth.uid);
  }

  // User subscriptions - users can read/write their own
  match /subscriptions/{subscriptionId} {
    allow read, write: if request.auth != null &&
      resource.data.userId == request.auth.uid;
    allow read: if _isAdmin(request.auth.uid); // Admins can view all
  }

  // XP transactions - users can read/write their own
  match /xp_transactions/{transactionId} {
    allow read, write: if request.auth != null &&
      resource.data.userId == request.auth.uid;
    allow read: if _isAdmin(request.auth.uid); // Admins can view all
  }
}